<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Appmetrics by avalente</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Appmetrics</h1>
        <p>Application level metrics collector library</p>

        <p class="view"><a href="https://github.com/avalente/appmetrics">View the Project on GitHub <small>avalente/appmetrics</small></a></p>


        <ul>
          <li><a href="https://github.com/avalente/appmetrics/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/avalente/appmetrics/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/avalente/appmetrics">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>AppMetrics
++++++++++</p>

<p>.. image:: <a href="https://travis-ci.org/avalente/appmetrics.png?branch=master">https://travis-ci.org/avalente/appmetrics.png?branch=master</a>
    :target: <a href="https://travis-ci.org/avalente/appmetrics">https://travis-ci.org/avalente/appmetrics</a>
    :alt: Build status</p>

<p><em>AppMetrics</em> is a python library used to collect useful run-time application's metrics, based on
<code>Folsom from Boundary &lt;https://github.com/boundary/folsom&gt;</code><em>, which is in turn inspired by
<code>Metrics from Coda Hale &lt;https://github.com/codahale/metrics&gt;</code></em>.</p>

<p>The library's purpose is to help you collect realtime metrics from your Python applications,
being them web apps, long-running batches or whatever. <em>AppMetrics</em> is not a persistent store,
you must provide your own persistence layer, maybe by using well established monitoring tools.</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>Once that you installed <em>AppMetrics</em> package in your python environment
(a <em>python setup.py install</em> is enough), you can access it by the <em>metrics</em> module::</p>

<pre><code>&gt;&gt;&gt; from appmetrics import metrics
&gt;&gt;&gt; histogram = metrics.new_histogram("test")
&gt;&gt;&gt; histogram.notify(1.0)
True
&gt;&gt;&gt; histogram.notify(2.0)
True
&gt;&gt;&gt; histogram.notify(3.0)
True
&gt;&gt;&gt; histogram.get()
{'arithmetic_mean': 2.0, 'skewness': 0.0, 'harmonic_mean': 1.6363636363636365, 'min': 1.0, 'standard_deviation': 1.0, 'median': 2.0, 'histogram': [(3.0, 3), (5.0, 0)], 'percentile': [(50, 2.0), (75, 2.0), (90, 3.0), (95, 3.0), (99, 3.0), (99.9, 3.0)], 'n': 3, 'max': 3.0, 'variance': 1.0, 'geometric_mean': 1.8171205928321397, 'kurtosis': -2.3333333333333335}
</code></pre>

<p>Basically you create a new metric by using one of the <em>metrics.new_\</em>* functions. The metric will be stored into
an internal registry, so you can access it in different places in your application::</p>

<pre><code>&gt;&gt;&gt; test_histogram = metrics.metric("test")
&gt;&gt;&gt; test_histogram.notify(4.0)
True
</code></pre>

<p>The <em>metrics</em> registry is thread-safe, you can safely use it in multi-threaded web servers.</p>

<h2>
<a name="api" class="anchor" href="#api"><span class="octicon octicon-link"></span></a>API</h2>

<p><em>AppMetrics</em> exposes a simple and consistent API: all the metric objects have three methods:</p>

<ul>
<li>notify(value)   - add a new value to the metric</li>
<li>get()           - get the computed metric's value (if any)</li>
<li>raw_data()      - get the raw data stored in the metrics</li>
</ul><p>However, the <em>notify</em> input type depends on the kind of metric chosen.</p>

<h2>
<a name="metrics" class="anchor" href="#metrics"><span class="octicon octicon-link"></span></a>Metrics</h2>

<p>Several metric types are available:</p>

<p>Counters</p>

<hr><p>Counter metrics provide increment and decrement capabilities for a single integer value.
The <em>notify</em> method accepts an integer: the counter will be incremented or decremented according
to the value's sign. Notice that the function tries to cast the input value to integer, so
a <em>TypeError</em> or a <em>ValueError</em> may be raised::</p>

<pre><code>&gt;&gt;&gt; counter = metrics.new_counter("test")
&gt;&gt;&gt; counter.notify(10)
&gt;&gt;&gt; counter.notify(-5)
&gt;&gt;&gt; counter.get()
5
&gt;&gt;&gt; counter.notify("wrong")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "appmetrics/simple_metrics.py", line 40, in notify
    value = int(value)
ValueError: invalid literal for int() with base 10: 'wrong'
</code></pre>

<p>Gauges</p>

<hr><p>Gauges are point-in-time single value metrics. The <em>notify</em> method accepts any data type::</p>

<pre><code>&gt;&gt;&gt; gauge = metrics.new_gauge("gauge_test")
&gt;&gt;&gt; gauge.notify("version 1.0")
&gt;&gt;&gt; gauge.get()
'version 1.0'
</code></pre>

<p>The <em>gauge</em> metric is useful to expose almost-static values such as configuration parameters, constants and so on.</p>

<p>Histograms</p>

<hr><p>Histograms are collections of values on which statistical analysis are performed automatically. They are useful
to know how the application is performing. The <em>notify</em> method accepts a single floating-point value, while
the <em>get</em> method computes and returns the following values:</p>

<ul>
<li>arithmetic mean</li>
<li>geometric mean</li>
<li>harmonic mean</li>
<li>data distribution histogram with automatic bins</li>
<li>kurtosis</li>
<li>maximum value</li>
<li>median</li>
<li>minimum value</li>
<li>number of values</li>
<li>50, 75, 90, 95, 99 and 99.9th percentiles of the data distribution</li>
<li>skewness</li>
<li>standard deviation</li>
<li>variance</li>
</ul><p>Notice that the <em>notify</em> method tries to cast the input value to a float, so a <em>TypeError</em> or a <em>ValueError</em> may
be raised.</p>

<p>Sample types
^^^^^^^^^^^^</p>

<p>To avoid unbound memory usage, the histogram metrics are generated from a <em>reservoir</em> of values. Currently
the only <em>reservoir</em> type available is the <em>uniform</em> one, in which a fixed number of values (default 1028)
is kept, and when the reservoir is full new values replace older ones randomly, ensuring that the
sample is always statistically representative.</p>

<p>Meters</p>

<hr><p>Meters are increment-only counters that measure the rate of events (such as "http requests") over time. This kind of
metric is useful to collect throughput values (such as "requests per second"), both on average and on different time
intervals::</p>

<pre><code>&gt;&gt;&gt; meter = metrics.new_meter("meter_test")
&gt;&gt;&gt; meter.notify(1)
&gt;&gt;&gt; meter.notify(1)
&gt;&gt;&gt; meter.notify(3)
&gt;&gt;&gt; meter.get()
{'count': 5, 'five': 0.01652854617838251, 'mean': 0.34341050858242983, 'fifteen': 0.005540151995103271, 'day': 5.7868695912732804e-05, 'one': 0.07995558537067671}
</code></pre>

<p>The return values of the <em>get</em> method are the following:</p>

<ul>
<li>count: number of operations collected so far</li>
<li>mean: the average throughput since the metric creation</li>
<li>one: one-minute
<code>exponentially-weighted moving average &lt;http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average&gt;</code>_
(<em>EWMA</em>)</li>
<li>five: five-minutes <em>EWMA</em>
</li>
<li>fifteen: fifteen-minutes <em>EWMA</em>
</li>
<li>day: last day <em>EWMA</em>
</li>
</ul><h2>
<a name="external-access" class="anchor" href="#external-access"><span class="octicon octicon-link"></span></a>External access</h2>

<p>You can access the metrics provided by <em>AppMetrics</em> externally by the WSGI
middleware found in <em>appmetrics.wsgi.AppMetricsMiddleware</em>. It is a standard WSGI
middleware without external dependencies and it can be plugged in any framework supporting
the WSGI standard, for example in a <em>Flask</em> application::</p>

<pre><code>from flask import Flask
from appmetrics import metrics

metrics.new_histogram("test-histogram")
metrics.new_gauge("test-counter")
metrics.metric("test-counter").notify(10)

app = Flask(__name__)

@app.route('/hello')
def hello_world():
    return 'Hello World!'

if __name__ == '__main__':
    from appmetrics.wsgi import AppMetricsMiddleware
    app.wsgi_app = AppMetricsMiddleware(app.wsgi_app)
    app.run()
</code></pre>

<p>If you launch the above application you can ask for metrics::</p>

<pre><code>$ curl http://localhost:5000/hello
Hello World!

$ curl http://localhost:5000/_app-metrics
["test-counter", "test-histogram"]

$ curl http://localhost:5000/_app-metrics/test-counter
10
</code></pre>

<p>In this way you can easily expose your application's metrics to an external monitoring service.
Moreover, since the <em>AppMetricsMiddleware</em> exposes a full RESTful API, you can create metrics
from anywhere and also populate them with foreign application's data.</p>

<p>Usage</p>

<hr><p>As usual, instantiate the middleware with the wrapped WSGI application; it looks for
request paths starting with <em>"/_app-metrics"</em>: if not found, the wrapped application
is called. The following resources are defined:</p>

<ul>
<li>/_app-metrics:

<ul>
<li>GET: return the list of the registered metrics</li>
</ul>
</li>
<li>/_app-metrics/:

<ul>
<li>GET: return the value of the given metric or 404</li>
<li>PUT: create a new metric with the given name. The body must be a JSON object with a
    mandatory attribute named <em>"type"</em> which must be one of the metrics types allowed,
    by the <em>"metrics.METRIC_TYPES"</em> dictionary, while the other attributes are
    passed to the <em>new_</em> function as keyword arguments.
    Request's content-type must be <em>"application/json"</em>.</li>
<li>POST: add a new value to the metric. The body must be a JSON object with a mandatory
     attribute named <em>"value"</em>: the notify method will be called with the given value.
     Other attributes are ignored.
     Request's content-type must be <em>"application/json"</em>
</li>
</ul>
</li>
</ul><p>The root can be different from <em>"/_app-metrics"</em>, you can pass it to the middleware constructor.</p>

<h2>
<a name="testing" class="anchor" href="#testing"><span class="octicon octicon-link"></span></a>Testing</h2>

<p><em>AppMetrics</em> has an exhaustive test suite, made up by both doctests and unit tests. To run the
whole test suite (including the coverage test), just issue:</p>

<p>$ nosetests --with-doctest --with-coverage --cover-package=appmetrics --cover-erase</p>

<p>You will need to install a couple of packages in your python environment, the list is in the "requirements.txt" file.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/avalente">avalente</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>