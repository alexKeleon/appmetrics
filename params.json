{"name":"Appmetrics","tagline":"Application level metrics collector library","body":"AppMetrics\r\n++++++++++\r\n\r\n.. image:: https://travis-ci.org/avalente/appmetrics.png?branch=master\r\n    :target: https://travis-ci.org/avalente/appmetrics\r\n    :alt: Build status\r\n\r\n\r\n*AppMetrics* is a python library used to collect useful run-time application's metrics, based on\r\n`Folsom from Boundary <https://github.com/boundary/folsom>`_, which is in turn inspired by\r\n`Metrics from Coda Hale <https://github.com/codahale/metrics>`_.\r\n\r\nThe library's purpose is to help you collect realtime metrics from your Python applications,\r\nbeing them web apps, long-running batches or whatever. *AppMetrics* is not a persistent store,\r\nyou must provide your own persistence layer, maybe by using well established monitoring tools.\r\n\r\nUsage\r\n-----\r\n\r\nOnce that you installed *AppMetrics* package in your python environment\r\n(a *python setup.py install* is enough), you can access it by the *metrics* module::\r\n\r\n    >>> from appmetrics import metrics\r\n    >>> histogram = metrics.new_histogram(\"test\")\r\n    >>> histogram.notify(1.0)\r\n    True\r\n    >>> histogram.notify(2.0)\r\n    True\r\n    >>> histogram.notify(3.0)\r\n    True\r\n    >>> histogram.get()\r\n    {'arithmetic_mean': 2.0, 'skewness': 0.0, 'harmonic_mean': 1.6363636363636365, 'min': 1.0, 'standard_deviation': 1.0, 'median': 2.0, 'histogram': [(3.0, 3), (5.0, 0)], 'percentile': [(50, 2.0), (75, 2.0), (90, 3.0), (95, 3.0), (99, 3.0), (99.9, 3.0)], 'n': 3, 'max': 3.0, 'variance': 1.0, 'geometric_mean': 1.8171205928321397, 'kurtosis': -2.3333333333333335}\r\n\r\nBasically you create a new metric by using one of the *metrics.new_\\** functions. The metric will be stored into\r\nan internal registry, so you can access it in different places in your application::\r\n\r\n    >>> test_histogram = metrics.metric(\"test\")\r\n    >>> test_histogram.notify(4.0)\r\n    True\r\n\r\nThe *metrics* registry is thread-safe, you can safely use it in multi-threaded web servers.\r\n\r\n\r\nAPI\r\n---\r\n\r\n*AppMetrics* exposes a simple and consistent API: all the metric objects have three methods:\r\n * notify(value)   - add a new value to the metric\r\n * get()           - get the computed metric's value (if any)\r\n * raw_data()      - get the raw data stored in the metrics\r\n\r\nHowever, the *notify* input type depends on the kind of metric chosen.\r\n\r\nMetrics\r\n-------\r\n\r\nSeveral metric types are available:\r\n\r\nCounters\r\n********\r\n\r\nCounter metrics provide increment and decrement capabilities for a single integer value.\r\nThe *notify* method accepts an integer: the counter will be incremented or decremented according\r\nto the value's sign. Notice that the function tries to cast the input value to integer, so\r\na *TypeError* or a *ValueError* may be raised::\r\n\r\n    >>> counter = metrics.new_counter(\"test\")\r\n    >>> counter.notify(10)\r\n    >>> counter.notify(-5)\r\n    >>> counter.get()\r\n    5\r\n    >>> counter.notify(\"wrong\")\r\n    Traceback (most recent call last):\r\n      File \"<stdin>\", line 1, in <module>\r\n      File \"appmetrics/simple_metrics.py\", line 40, in notify\r\n        value = int(value)\r\n    ValueError: invalid literal for int() with base 10: 'wrong'\r\n\r\nGauges\r\n******\r\n\r\nGauges are point-in-time single value metrics. The *notify* method accepts any data type::\r\n\r\n    >>> gauge = metrics.new_gauge(\"gauge_test\")\r\n    >>> gauge.notify(\"version 1.0\")\r\n    >>> gauge.get()\r\n    'version 1.0'\r\n\r\nThe *gauge* metric is useful to expose almost-static values such as configuration parameters, constants and so on.\r\n\r\nHistograms\r\n**********\r\n\r\nHistograms are collections of values on which statistical analysis are performed automatically. They are useful\r\nto know how the application is performing. The *notify* method accepts a single floating-point value, while\r\nthe *get* method computes and returns the following values:\r\n\r\n * arithmetic mean\r\n * geometric mean\r\n * harmonic mean\r\n * data distribution histogram with automatic bins\r\n * kurtosis\r\n * maximum value\r\n * median\r\n * minimum value\r\n * number of values\r\n * 50, 75, 90, 95, 99 and 99.9th percentiles of the data distribution\r\n * skewness\r\n * standard deviation\r\n * variance\r\n\r\nNotice that the *notify* method tries to cast the input value to a float, so a *TypeError* or a *ValueError* may\r\nbe raised.\r\n\r\nSample types\r\n^^^^^^^^^^^^\r\n\r\nTo avoid unbound memory usage, the histogram metrics are generated from a *reservoir* of values. Currently\r\nthe only *reservoir* type available is the *uniform* one, in which a fixed number of values (default 1028)\r\nis kept, and when the reservoir is full new values replace older ones randomly, ensuring that the\r\nsample is always statistically representative.\r\n\r\nMeters\r\n******\r\n\r\nMeters are increment-only counters that measure the rate of events (such as \"http requests\") over time. This kind of\r\nmetric is useful to collect throughput values (such as \"requests per second\"), both on average and on different time\r\nintervals::\r\n\r\n    >>> meter = metrics.new_meter(\"meter_test\")\r\n    >>> meter.notify(1)\r\n    >>> meter.notify(1)\r\n    >>> meter.notify(3)\r\n    >>> meter.get()\r\n    {'count': 5, 'five': 0.01652854617838251, 'mean': 0.34341050858242983, 'fifteen': 0.005540151995103271, 'day': 5.7868695912732804e-05, 'one': 0.07995558537067671}\r\n\r\nThe return values of the *get* method are the following:\r\n\r\n - count: number of operations collected so far\r\n - mean: the average throughput since the metric creation\r\n - one: one-minute\r\n   `exponentially-weighted moving average <http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average>`_\r\n   (*EWMA*)\r\n - five: five-minutes *EWMA*\r\n - fifteen: fifteen-minutes *EWMA*\r\n - day: last day *EWMA*\r\n\r\n\r\nExternal access\r\n---------------\r\n\r\nYou can access the metrics provided by *AppMetrics* externally by the WSGI\r\nmiddleware found in *appmetrics.wsgi.AppMetricsMiddleware*. It is a standard WSGI\r\nmiddleware without external dependencies and it can be plugged in any framework supporting\r\nthe WSGI standard, for example in a *Flask* application::\r\n\r\n    from flask import Flask\r\n    from appmetrics import metrics\r\n\r\n    metrics.new_histogram(\"test-histogram\")\r\n    metrics.new_gauge(\"test-counter\")\r\n    metrics.metric(\"test-counter\").notify(10)\r\n\r\n    app = Flask(__name__)\r\n\r\n    @app.route('/hello')\r\n    def hello_world():\r\n        return 'Hello World!'\r\n\r\n    if __name__ == '__main__':\r\n        from appmetrics.wsgi import AppMetricsMiddleware\r\n        app.wsgi_app = AppMetricsMiddleware(app.wsgi_app)\r\n        app.run()\r\n\r\nIf you launch the above application you can ask for metrics::\r\n\r\n    $ curl http://localhost:5000/hello\r\n    Hello World!\r\n\r\n    $ curl http://localhost:5000/_app-metrics\r\n    [\"test-counter\", \"test-histogram\"]\r\n\r\n    $ curl http://localhost:5000/_app-metrics/test-counter\r\n    10\r\n\r\nIn this way you can easily expose your application's metrics to an external monitoring service.\r\nMoreover, since the *AppMetricsMiddleware* exposes a full RESTful API, you can create metrics\r\nfrom anywhere and also populate them with foreign application's data.\r\n\r\nUsage\r\n*****\r\n\r\nAs usual, instantiate the middleware with the wrapped WSGI application; it looks for\r\nrequest paths starting with *\"/_app-metrics\"*: if not found, the wrapped application\r\nis called. The following resources are defined:\r\n\r\n - /_app-metrics:\r\n     - GET: return the list of the registered metrics\r\n - /_app-metrics/<name>:\r\n     - GET: return the value of the given metric or 404\r\n     - PUT: create a new metric with the given name. The body must be a JSON object with a\r\n            mandatory attribute named *\"type\"* which must be one of the metrics types allowed,\r\n            by the *\"metrics.METRIC_TYPES\"* dictionary, while the other attributes are\r\n            passed to the *new_<type>* function as keyword arguments.\r\n            Request's content-type must be *\"application/json\"*.\r\n     - POST: add a new value to the metric. The body must be a JSON object with a mandatory\r\n             attribute named *\"value\"*: the notify method will be called with the given value.\r\n             Other attributes are ignored.\r\n             Request's content-type must be *\"application/json\"*\r\n\r\nThe root can be different from *\"/_app-metrics\"*, you can pass it to the middleware constructor.\r\n\r\n\r\nTesting\r\n-------\r\n\r\n*AppMetrics* has an exhaustive test suite, made up by both doctests and unit tests. To run the\r\nwhole test suite (including the coverage test), just issue:\r\n\r\n $ nosetests --with-doctest --with-coverage --cover-package=appmetrics --cover-erase\r\n\r\nYou will need to install a couple of packages in your python environment, the list is in the \"requirements.txt\" file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}